(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{415:function(t,e,i){"use strict";i.r(e);var v=i(31),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"ipv4패킷-헤더-구조"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#ipv4패킷-헤더-구조"}},[t._v("#")]),t._v(" IPv4패킷 헤더 구조")]),t._v(" "),i("p",[i("img",{attrs:{src:"/images/TIL/CS%20-%20Network/ipv4-header.png",alt:"ip패킷구조"}})]),t._v(" "),i("p",[t._v("IP패킷은 라우터 "),i("strong",[t._v("MTU")]),t._v("(Maximum Transfer Unit)에 맞게 전송해야 한다."),i("br"),t._v("\n패킷의 크기가 클 경우 단편화가 일어나게 된다.")]),t._v(" "),i("ul",[i("li",[i("strong",[t._v("Version")]),t._v(" - 4bit\n"),i("ul",[i("li",[t._v("IPv4인지 IPv6인지 구별해줌\n"),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("IHL (Header Length)")]),t._v(" - 4bit\n"),i("ul",[i("li",[t._v("헤더의 길이가 담겨있음 (MIN 20byte ~ MAX 40byte)")]),t._v(" "),i("li",[t._v("D : 이 플래그가 체크되어 있으면 단편화를 할 수 없다.")]),t._v(" "),i("li",[t._v("M : 1이면 단편화된 조각이 더 있다는 뜻이고 0이면 마지막 패킷이라는 뜻\n"),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("TOS (Type Of Service)")]),t._v(" - 8bit\n"),i("ul",[i("li",[t._v("서비스(=패킷 처리)에 대한 우선순위를 설정할 수 있음")]),t._v(" "),i("li",[t._v("우선순위를 나타내는 Precedence (3bit) + 서비스 유형지정비트 (4bit) + 사용되지 않는 1bit 로 이루어져 있음\n"),i("img",{attrs:{src:"/images/TIL/CS%20-%20Network/tos.png",alt:"tos"}}),i("br"),t._v(" "),i("img",{attrs:{src:"/images/TIL/CS%20-%20Network/tos-2.png",alt:"tos-2"}}),t._v(" "),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("Total Length")]),t._v(" - 16bit\n"),i("ul",[i("li",[t._v("헤더와 데이터를 포함한 패킷의 전체 길이를 나타낸다.\n"),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("Identification")]),t._v(" - 16bit\n"),i("ul",[i("li",[t._v("전체 IP 패킷의 길이를 바이트 단위로 나타낸다.\n"),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("IP Flags")]),t._v(" - 3bit\n"),i("ul",[i("li",[t._v("IP 패킷의 Fragmentation 가능 여부와 마지막 Fragment인지 아닌지를 알리기 위해 사용되는 필드")]),t._v(" "),i("li",[t._v("Reserved Flag (1번째 1bit) : 항상 0으로 설정되어 있다.")]),t._v(" "),i("li",[t._v("May Fragment (2번째 1bit) : IP 라우터에 의해 분열되는 여부를 나타낸다.\n"),i("ul",[i("li",[t._v("0 = 분열 가능")]),t._v(" "),i("li",[t._v("1 = 분열 방지")])])]),t._v(" "),i("li",[t._v("More Fragment (3번쨰 1bit) : 분열된 조각이 더 있는지 확인하는 bit - 0 = 마지막 조각 - 1 = 조각이 더 있음\n"),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("Fragment Offset")]),t._v(" (13bit)\n"),i("ul",[i("li",[t._v("8바이트 오프셋으로 조각에 저장된 원래 데이터의 바이트 범위를 나타낸다."),i("br"),t._v(" "),i("img",{attrs:{src:"/images/TIL/CS%20-%20Network/fregmentation.png",alt:"fregmentation"}}),t._v(" "),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("TTL (Time To Live)")]),t._v(" (8bit)\n"),i("ul",[i("li",[t._v("패킷이 무한루핑 하는 것을 방지하기 위하여 만들어졌으며 라우터를 지날 때마다 1씩 감소한다.")]),t._v(" "),i("li",[t._v("0이 되면 해당 패킷은 폐기되고 Type3의 Destination Unreachable을 보내준다.\n"),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("Protocol Identifier")]),t._v(" (8bit)\n"),i("ul",[i("li",[t._v("어떤 프로토콜을 사용하는지 명시하는 필드이다.\n"),i("table",[i("thead",[i("tr",[i("th",{staticStyle:{"text-align":"center"}},[t._v("Protocol Number")]),t._v(" "),i("th",{staticStyle:{"text-align":"center"}},[t._v("Protocol Type")])])]),t._v(" "),i("tbody",[i("tr",[i("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),i("td",{staticStyle:{"text-align":"center"}},[t._v("ICMP")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),i("td",{staticStyle:{"text-align":"center"}},[t._v("IGMP")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"center"}},[t._v("6")]),t._v(" "),i("td",{staticStyle:{"text-align":"center"}},[t._v("TCP")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"center"}},[t._v("17")]),t._v(" "),i("td",{staticStyle:{"text-align":"center"}},[t._v("UDP")])])])]),t._v(" "),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("Header Checksum")]),t._v(" (16bit)\n"),i("ul",[i("li",[t._v("IP Header가 생성되거나 수정될 때마다 IP 헤더 내 비트를 검사한다.")]),t._v(" "),i("li",[t._v("IP 패킷이 전송되고 계산 결과가 똑같다면, IP헤더는 문제 없이 정확히 전송된 것이다.")]),t._v(" "),i("li",[t._v("계산방법 : 2byte씩 IP헤더를 모두 잘라 더한 후에 발생한 올림영역까지 더해준 후, 1의 보수(비트반전)을 시켜준다.\n"),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("Source IP Address")]),t._v(" - 32bit\n"),i("ul",[i("li",[t._v("출발지 IP 주소\n"),i("br"),i("br")])])]),t._v(" "),i("li",[i("strong",[t._v("Destination IP Address")]),t._v(" - 32bit\n"),i("ul",[i("li",[t._v("목적지 IP 주소\n"),i("br"),i("br")])])]),t._v(" "),i("li",[t._v("IP Option (가변 bit)\n"),i("ul",[i("li",[t._v("Type-of-Service 플래그처럼 특별한 처리 옵션을 추가로 정의할 수 있다.")])])])]),t._v(" "),i("p",[i("br"),i("br")]),t._v(" "),i("h2",{attrs:{id:"ipv6-header-구조-번외"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#ipv6-header-구조-번외"}},[t._v("#")]),t._v(" IPv6 header 구조 (번외)")]),t._v(" "),i("p",[i("img",{attrs:{src:"/images/TIL/CS%20-%20Network/ipv6.png",alt:"ipv6"}})])])}),[],!1,null,null,null);e.default=r.exports}}]);