# 11장. 원시값과 객체의 비교

- 원시값을 변수에 할당 ⇒ **실제 값**이 저장됨(immutable)
- 객체를 변수에 할당 ⇒ **참조** **값**이 저장됨(mutable)

- 상수 : 재할당이 금지된 변수
- 객체 : const로 선언해도 내부의 값은 변경할 수 있다.

- 원시값을 변경할 경우 → 새로운 메모리 공간을 참조한다.

## 유사 배열 객체

마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.

for 문으로 순회할 수도 있다.

- 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환된다.

```jsx
// 문자열을 예로 들자면
var str = 'string';

console.log(str[0]); // 배열처럼 접근할 수 있다.

console.log(str.length); // 객체처럼 .length가 가능하다.
console.log(str.toUpperCase());
```

## 문자열

유사배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

**문자열을 변경하는것은 안되지만 새 문자열을 재할당하는것은 가능하다.**

```jsx
var str = 'string';

// 원시값이므로 변경이 불가능하다. 하지만 에러는 발생하지 않는다.
str[0] = 'S';

console.log(str); // "string"

str = 'hello';
console.log(str); // "hello"
```

## Call By Sharing (= 공유에 의한 전달)

```jsx
var score = 80;
var copy = score;

console.log(score); // 80
consoel.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

자바스크립트는 call by value, call by reference가 아닌 call by sharing이다.

call by value와 같이 값을 복사하는것처럼 보이지만, 사실은 메모리를 참조해서 복사한다.

값을 복사하는 것이 아닌 **참조값의 복사본**을 만들어서 넘기는 것이다.

## 객체

- 자바스크립트는 클래스 없이 객체를 생성할 수 있다.
- 동적으로 프로퍼티와 메서드를 추가할 수 있다.
- 객체는 원시값과 달리 참조값에 접근할 수 있다. 그렇기에 상수로 선언하더라도 참조값(메모리주소)만 바꿀수 없을 뿐, 내부 프로퍼티들은 수정이 가능하다.

## 얕은복사, 깊은복사

- 얕은복사 : 객체에 중첩되어 있는 객체의 경우 참조값을 복사한다.
- 깊은복사 : 중첩되어 있는 객체까지 모두 복사해서 원시값처럼 완전한 복사본을 만든다.

객체를 할당한 변수를 다른 변수에 할당하는 것 → 얕은 복사

원시값을 할당한 변수를 다른 변수에 할당하는 것 → 깊은 복사
